{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"language\", \"loginHint\", \"selectAccount\", \"extraParams\", \"clientSecret\"],\n    _excluded2 = [\"extraParams\"];\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as Application from 'expo-application';\nimport { useEffect, useMemo, useState } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { useAuthRequestResult, useLoadedAuthRequest } from \"../AuthRequestHooks\";\nimport { AuthRequest, generateHexStringAsync, makeRedirectUri, Prompt, ResponseType } from \"../AuthSession\";\nimport { AccessTokenRequest } from \"../TokenRequest\";\nimport { applyRequiredScopes, invariantClientId, useProxyEnabled } from \"./ProviderUtils\";\nvar settings = {\n  windowFeatures: {\n    width: 515,\n    height: 680\n  },\n  minimumScopes: ['openid', 'https://www.googleapis.com/auth/userinfo.profile', 'https://www.googleapis.com/auth/userinfo.email']\n};\nexport var discovery = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo'\n};\n\nvar GoogleAuthRequest = function (_AuthRequest) {\n  _inherits(GoogleAuthRequest, _AuthRequest);\n\n  var _super = _createSuper(GoogleAuthRequest);\n\n  function GoogleAuthRequest(_ref) {\n    var language = _ref.language,\n        loginHint = _ref.loginHint,\n        selectAccount = _ref.selectAccount,\n        _ref$extraParams = _ref.extraParams,\n        extraParams = _ref$extraParams === void 0 ? {} : _ref$extraParams,\n        clientSecret = _ref.clientSecret,\n        config = _objectWithoutProperties(_ref, _excluded);\n\n    _classCallCheck(this, GoogleAuthRequest);\n\n    var inputParams = _objectSpread({}, extraParams);\n\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n    var scopes = applyRequiredScopes(config.scopes, settings.minimumScopes);\n    var isImplicit = config.responseType === ResponseType.Token || config.responseType === ResponseType.IdToken;\n\n    if (isImplicit) {\n      config.usePKCE = false;\n    }\n\n    var inputClientSecret;\n\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      inputClientSecret = clientSecret;\n    }\n\n    return _super.call(this, _objectSpread(_objectSpread({}, config), {}, {\n      clientSecret: inputClientSecret,\n      scopes: scopes,\n      extraParams: inputParams\n    }));\n  }\n\n  _createClass(GoogleAuthRequest, [{\n    key: \"getAuthRequestConfigAsync\",\n    value: function getAuthRequestConfigAsync() {\n      var _await$_get$call, _await$_get$call$extr, extraParams, config;\n\n      return _regeneratorRuntime.async(function getAuthRequestConfigAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(_get(_getPrototypeOf(GoogleAuthRequest.prototype), \"getAuthRequestConfigAsync\", this).call(this));\n\n            case 2:\n              _await$_get$call = _context.sent;\n              _await$_get$call$extr = _await$_get$call.extraParams;\n              extraParams = _await$_get$call$extr === void 0 ? {} : _await$_get$call$extr;\n              config = _objectWithoutProperties(_await$_get$call, _excluded2);\n\n              if (!(config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce)) {\n                _context.next = 12;\n                break;\n              }\n\n              if (this.nonce) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.next = 10;\n              return _regeneratorRuntime.awrap(generateHexStringAsync(16));\n\n            case 10:\n              this.nonce = _context.sent;\n\n            case 11:\n              extraParams.nonce = this.nonce;\n\n            case 12:\n              return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, config), {}, {\n                extraParams: extraParams\n              }));\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return GoogleAuthRequest;\n}(AuthRequest);\n\nexport function useIdTokenAuthRequest(config) {\n  var redirectUriOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var useProxy = useProxyEnabled(redirectUriOptions);\n  var isWebAuth = useProxy || Platform.OS === 'web';\n  return useAuthRequest(_objectSpread(_objectSpread({}, config), {}, {\n    responseType: !config.clientSecret && isWebAuth ? ResponseType.IdToken : undefined\n  }), _objectSpread(_objectSpread({}, redirectUriOptions), {}, {\n    useProxy: useProxy\n  }));\n}\nexport function useAuthRequest() {\n  var _config$scopes;\n\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var redirectUriOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var useProxy = useProxyEnabled(redirectUriOptions);\n  var clientId = useMemo(function () {\n    var _config$propertyName;\n\n    var propertyName = useProxy ? 'expoClientId' : Platform.select({\n      ios: 'iosClientId',\n      android: 'androidClientId',\n      default: 'webClientId'\n    });\n    var clientId = (_config$propertyName = config[propertyName]) != null ? _config$propertyName : config.clientId;\n    invariantClientId(propertyName, clientId, 'Google');\n    return clientId;\n  }, [useProxy, config.expoClientId, config.iosClientId, config.androidClientId, config.webClientId, config.clientId]);\n  var responseType = useMemo(function () {\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n\n    var isInstalledApp = Platform.OS !== 'web' && !useProxy;\n\n    if (config.clientSecret || isInstalledApp) {\n      return ResponseType.Code;\n    }\n\n    return ResponseType.Token;\n  }, [config.responseType, config.clientSecret, useProxy]);\n  var redirectUri = useMemo(function () {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n\n    return makeRedirectUri(_objectSpread({\n      native: Application.applicationId + \":/oauthredirect\",\n      useProxy: useProxy\n    }, redirectUriOptions));\n  }, [useProxy, config.redirectUri, redirectUriOptions]);\n  var extraParams = useMemo(function () {\n    var output = config.extraParams ? _objectSpread({}, config.extraParams) : {};\n\n    if (config.language) {\n      output.hl = output.language;\n    }\n\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n\n    if (config.selectAccount) {\n      output.prompt = Prompt.SelectAccount;\n    }\n\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n  var request = useLoadedAuthRequest(_objectSpread(_objectSpread({}, config), {}, {\n    responseType: responseType,\n    extraParams: extraParams,\n    clientId: clientId,\n    redirectUri: redirectUri\n  }), discovery, GoogleAuthRequest);\n\n  var _useAuthRequestResult = useAuthRequestResult(request, discovery, {\n    useProxy: useProxy,\n    windowFeatures: settings.windowFeatures\n  }),\n      _useAuthRequestResult2 = _slicedToArray(_useAuthRequestResult, 2),\n      result = _useAuthRequestResult2[0],\n      promptAsync = _useAuthRequestResult2[1];\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      fullResult = _useState2[0],\n      setFullResult = _useState2[1];\n\n  var shouldAutoExchangeCode = useMemo(function () {\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n\n    var couldAutoExchange = (result == null ? void 0 : result.type) === 'success' && result.params.code && !result.authentication;\n    return couldAutoExchange;\n  }, [config.shouldAutoExchangeCode, result == null ? void 0 : result.type]);\n  useEffect(function () {\n    var isMounted = true;\n\n    if (shouldAutoExchangeCode && (result == null ? void 0 : result.type) === 'success') {\n      var exchangeRequest = new AccessTokenRequest({\n        clientId: clientId,\n        clientSecret: config.clientSecret,\n        redirectUri: redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          code_verifier: request.codeVerifier\n        }\n      });\n      exchangeRequest.performAsync(discovery).then(function (authentication) {\n        if (isMounted) {\n          setFullResult(_objectSpread(_objectSpread({}, result), {}, {\n            params: _objectSpread({\n              id_token: authentication.idToken,\n              access_token: authentication.accessToken\n            }, result.params),\n            authentication: authentication\n          }));\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [clientId, redirectUri, shouldAutoExchangeCode, config.clientSecret, (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(','), request == null ? void 0 : request.codeVerifier, result]);\n  return [request, fullResult, promptAsync];\n}","map":{"version":3,"sources":["../../src/providers/Google.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Application from 'expo-application';\nimport { useEffect, useMemo, useState } from 'react';\nimport { Platform } from 'react-native';\n\nimport { useAuthRequestResult, useLoadedAuthRequest } from '../AuthRequestHooks';\nimport {\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  DiscoveryDocument,\n  generateHexStringAsync,\n  makeRedirectUri,\n  Prompt,\n  ResponseType,\n} from '../AuthSession';\nimport { AccessTokenRequest } from '../TokenRequest';\nimport { ProviderAuthRequestConfig } from './Provider.types';\nimport { applyRequiredScopes, invariantClientId, useProxyEnabled } from './ProviderUtils';\n\nconst settings = {\n  windowFeatures: { width: 515, height: 680 },\n  minimumScopes: [\n    'openid',\n    'https://www.googleapis.com/auth/userinfo.profile',\n    'https://www.googleapis.com/auth/userinfo.email',\n  ],\n};\n\nexport const discovery: DiscoveryDocument = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo',\n};\n\nexport interface GoogleAuthRequestConfig extends ProviderAuthRequestConfig {\n  /**\n   * If the user's email address is known ahead of time, it can be supplied to be the default option.\n   * If the user has approved access for this app in the past then auth may return without any further interaction.\n   */\n  loginHint?: string;\n  /**\n   * When `true`, the service will allow the user to switch between accounts (if possible). Defaults to `false`.\n   */\n  selectAccount?: boolean;\n  /**\n   * Proxy client ID for use in the Expo client on iOS and Android.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Web Application\n   * - **URIs**: https://auth.expo.io\n   * - **Authorized redirect URIs**: https://auth.expo.io/@your-username/your-project-slug\n   */\n  expoClientId?: string;\n  /**\n   * Expo web client ID for use in the browser.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Web Application\n   * - Give it a name (e.g. \"Web App\").\n   * - **URIs** (Authorized JavaScript origins): https://localhost:19006 & https://yourwebsite.com\n   * - **Authorized redirect URIs**: https://localhost:19006 & https://yourwebsite.com\n   * - To test this be sure to start your app with `expo start:web --https`.\n   */\n  webClientId?: string;\n  /**\n   * iOS native client ID for use in standalone, bare workflow, and custom clients.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: iOS Application\n   * - Give it a name (e.g. \"iOS App\").\n   * - **Bundle ID**: Must match the value of `ios.bundleIdentifier` in your `app.json`.\n   * - Your app needs to conform to the URI scheme matching your bundle identifier.\n   *   - _Standalone_: Automatically added, do nothing.\n   *   - _Bare workflow_: Run `npx uri-scheme add <your bundle id> --ios`\n   * - To test this you can:\n   *   1. Eject to bare: `expo eject` and run `yarn ios`\n   *   2. Create a custom client: `expo client:ios`\n   *   3. Build a production IPA: `expo build:ios`\n   * - Whenever you change the values in `app.json` you'll need to rebuild the native app.\n   */\n  iosClientId?: string;\n  /**\n   * Android native client ID for use in standalone, and bare workflow.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Android Application\n   * - Give it a name (e.g. \"Android App\").\n   * - **Package name**: Must match the value of `android.package` in your `app.json`.\n   * - Your app needs to conform to the URI scheme matching your `android.package` (ex. `com.myname.mycoolapp:/`).\n   *   - _Standalone_: Automatically added, do nothing.\n   *   - _Bare workflow_: Run `npx uri-scheme add <your android.package> --android`\n   * - **Signing-certificate fingerprint**:\n   *   - Run `expo credentials:manager -p android` then select \"Update upload Keystore\" -> \"Generate new keystore\" -> \"Go back to experience overview\"\n   *   - Copy your \"Google Certificate Fingerprint\", it will output a string that looks like `A1:B2:C3` but longer.\n   * - To test this you can:\n   *   1. Eject to bare: `expo eject` and run `yarn ios`\n   *   2. Build a production IPA: `expo build:android`\n   */\n  androidClientId?: string;\n  /**\n   * Should the hook automatically exchange the response code for an authentication token.\n   *\n   * Defaults to true on installed apps (iOS, Android) when `ResponseType.Code` is used (default).\n   */\n  shouldAutoExchangeCode?: boolean;\n}\n\nclass GoogleAuthRequest extends AuthRequest {\n  nonce?: string;\n\n  constructor({\n    language,\n    loginHint,\n    selectAccount,\n    extraParams = {},\n    clientSecret,\n    ...config\n  }: GoogleAuthRequestConfig) {\n    const inputParams = {\n      ...extraParams,\n    };\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n\n    // Apply the default scopes\n    const scopes = applyRequiredScopes(config.scopes, settings.minimumScopes);\n    const isImplicit =\n      config.responseType === ResponseType.Token || config.responseType === ResponseType.IdToken;\n    if (isImplicit) {\n      // PKCE must be disabled in implicit mode.\n      config.usePKCE = false;\n    }\n    let inputClientSecret: string | undefined;\n    //  Google will throw if you attempt to use the client secret\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      // TODO: maybe warn that you shouldn't store the client secret on the client\n      inputClientSecret = clientSecret;\n    }\n    super({\n      ...config,\n      clientSecret: inputClientSecret,\n      scopes,\n      extraParams: inputParams,\n    });\n  }\n\n  /**\n   * Load and return a valid auth request based on the input config.\n   */\n  async getAuthRequestConfigAsync(): Promise<AuthRequestConfig> {\n    const { extraParams = {}, ...config } = await super.getAuthRequestConfigAsync();\n    if (config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n      if (!this.nonce) {\n        this.nonce = await generateHexStringAsync(16);\n      }\n      extraParams.nonce = this.nonce;\n    }\n    return {\n      ...config,\n      extraParams,\n    };\n  }\n}\n\n/**\n * Load an authorization request with an ID Token for authentication with Firebase.\n *\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * The id token can be retrieved with `response.params.id_token`.\n *\n * - [Get Started](https://docs.expo.io/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useIdTokenAuthRequest(\n  config: Partial<GoogleAuthRequestConfig>,\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const useProxy = useProxyEnabled(redirectUriOptions);\n\n  const isWebAuth = useProxy || Platform.OS === 'web';\n\n  return useAuthRequest(\n    {\n      ...config,\n      responseType:\n        // If the client secret is provided then code can be used\n        !config.clientSecret &&\n        // When web auth is used, we can request the `id_token` directly without exchanging a code.\n        isWebAuth\n          ? ResponseType.IdToken\n          : undefined,\n    },\n    { ...redirectUriOptions, useProxy }\n  );\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes, then the response will be fulfilled.\n *\n * - [Get Started](https://docs.expo.io/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useAuthRequest(\n  config: Partial<GoogleAuthRequestConfig> = {},\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const useProxy = useProxyEnabled(redirectUriOptions);\n\n  const clientId = useMemo((): string => {\n    const propertyName = useProxy\n      ? 'expoClientId'\n      : Platform.select({\n          ios: 'iosClientId',\n          android: 'androidClientId',\n          default: 'webClientId',\n        });\n\n    const clientId = config[propertyName as any] ?? config.clientId;\n    invariantClientId(propertyName, clientId, 'Google');\n    return clientId;\n  }, [\n    useProxy,\n    config.expoClientId,\n    config.iosClientId,\n    config.androidClientId,\n    config.webClientId,\n    config.clientId,\n  ]);\n\n  const responseType = useMemo(() => {\n    // Allow overrides.\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n    // You can only use `response_token=code` on installed apps (iOS, Android without proxy).\n    // Installed apps can auto exchange without a client secret and get the token and id-token (Firebase).\n    const isInstalledApp = Platform.OS !== 'web' && !useProxy;\n    // If the user provided the client secret (they shouldn't!) then use code exchange by default.\n    if (config.clientSecret || isInstalledApp) {\n      return ResponseType.Code;\n    }\n    // This seems the most pragmatic option since it can result in a full authentication on web and proxy platforms as expected.\n    return ResponseType.Token;\n  }, [config.responseType, config.clientSecret, useProxy]);\n\n  const redirectUri = useMemo((): string => {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n\n    return makeRedirectUri({\n      native: `${Application.applicationId}:/oauthredirect`,\n      useProxy,\n      ...redirectUriOptions,\n      // native: `com.googleusercontent.apps.${guid}:/oauthredirect`,\n    });\n  }, [useProxy, config.redirectUri, redirectUriOptions]);\n\n  const extraParams = useMemo((): GoogleAuthRequestConfig['extraParams'] => {\n    const output = config.extraParams ? { ...config.extraParams } : {};\n\n    if (config.language) {\n      output.hl = output.language;\n    }\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n    if (config.selectAccount) {\n      output.prompt = Prompt.SelectAccount;\n    }\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n\n  const request = useLoadedAuthRequest(\n    {\n      ...config,\n      responseType,\n      extraParams,\n      clientId,\n      redirectUri,\n    },\n    discovery,\n    GoogleAuthRequest\n  );\n\n  const [result, promptAsync] = useAuthRequestResult(request, discovery, {\n    useProxy,\n    windowFeatures: settings.windowFeatures,\n  });\n\n  const [fullResult, setFullResult] = useState<AuthSessionResult | null>(null);\n\n  const shouldAutoExchangeCode = useMemo(() => {\n    // allow overrides\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n\n    // has a code to exchange and doesn't have an authentication yet.\n    const couldAutoExchange =\n      result?.type === 'success' && result.params.code && !result.authentication;\n\n    return couldAutoExchange;\n  }, [config.shouldAutoExchangeCode, result?.type]);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (shouldAutoExchangeCode && result?.type === 'success') {\n      const exchangeRequest = new AccessTokenRequest({\n        clientId,\n        clientSecret: config.clientSecret,\n        redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          // @ts-ignore: allow for instances where PKCE is disabled\n          code_verifier: request.codeVerifier,\n        },\n      });\n      exchangeRequest.performAsync(discovery).then((authentication) => {\n        if (isMounted) {\n          setFullResult({\n            ...result,\n            params: {\n              // @ts-ignore: provide a singular interface for getting the id_token across all workflows that request it.\n              id_token: authentication.idToken,\n              access_token: authentication.accessToken,\n              ...result.params,\n            },\n            authentication,\n          });\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    clientId,\n    redirectUri,\n    shouldAutoExchangeCode,\n    config.clientSecret,\n    config.scopes?.join(','),\n    request?.codeVerifier,\n    result,\n  ]);\n\n  return [request, fullResult, promptAsync];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}